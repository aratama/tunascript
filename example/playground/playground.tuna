import { log, toString, getArgs, getEnv, type Error } from "prelude"
import { parse, decode } from "json"
import { length } from "array"
import { runSandbox, runFormatter } from "runtime"
import { createServer, addRoute, listen, responseHtml, responseRedirect, type JSX, type Request, type Response } from "http"
import { dbOpen } from "sqlite"
import { readText } from "file"
import style from "./style.css"
import { PLAYGROUND_EDITOR_JS } from "./editor_script.tuna"
import TUNASCRIPT_LEZER_GRAMMAR from "./tunascript.grammar"

type RunResult = {
  stdout: string,
  html: string,
  exitCode: integer,
  error: string
}

create_table playground_sources {
  id TEXT PRIMARY KEY,
  source TEXT NOT NULL,
  updated_at TEXT NOT NULL
}

const MAX_SOURCE_SIZE_BYTES: integer = 10240
const DEFAULT_SOURCE_PATH: string = "example/playground/default_source.tuna"

function loadDefaultSource(): string {
  const fallback: string | Error = readText(DEFAULT_SOURCE_PATH)
  return switch (fallback) {
    case source as string: source
    case fallbackError as Error: ""
  } 
}

const DEFAULT_SOURCE: string = loadDefaultSource()

function Layout(source: string, stdout: string, html: string, error: string, exitCode: string, runPath: string, pagePath: string): JSX {
  return (
    <html>
      <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=M+PLUS+1+Code:wght@400;500;700&display=swap" />
        <title>TunaScript Playground</title>
        <style>{style}</style>
      </head>
      <body>
        <main class="layout">
          <section class="panel">
            <form method="POST" action={runPath} class="editor-form">
              <header class="bar">
                <span class="title">TunaScript Playground</span>
                <span class="actions">
                  <button class="button" type="submit">Format & Run</button>
                </span>
              </header>
              <div id="source-editor" class="editor-shell"></div>
              <textarea id="source-input" name="source" class="editor-source" spellcheck="false" wrap="off">{source}</textarea>
            </form>
          </section>
          <section class="right">
            <article class="panel">
              <header class="bar">
                <span class="title">Stdout</span>
                <span class="status">exitCode: {exitCode}</span>
              </header>
              <pre class="stdout">{stdout}</pre>
              <div class="error">{error}</div>
            </article>
            <article class="panel">
              <header class="bar">
                <span class="title">HTML Preview</span>
              </header>
              <iframe srcdoc={html} title="HTML preview"></iframe>
            </article>
          </section>
        </main>
        <script type="module">{PLAYGROUND_EDITOR_JS}</script>
      </body>
    </html>
  )
}

function validateSourceSize(source: string): string {
  const checked = fetch_one {
    SELECT length(hex({source})) / 2 > {MAX_SOURCE_SIZE_BYTES} AS too_large
  }
  return switch (checked) {
    case e as Error: "db error: " + e.message
    case row as { too_large: string }: if (row.too_large == "1") { "source is too large (max 10KB)" } else { "" }
  }
}

function handleRoot(req: Request): Response {
  return runSource(DEFAULT_SOURCE, "/run", "/")
}

function handleGrammar(req: Request): Response {
  return responseHtml(TUNASCRIPT_LEZER_GRAMMAR)
}

function handleSnippet(req: Request): Response {
  const id = req.query.id
  const pagePath = "/" + id
  const runPath = "/run/" + id
  if (id == "") {
    return responseHtml(Layout(DEFAULT_SOURCE, "", "", "invalid snippet id", "1", "/run", "/"))
  }

  const fetched = fetch_optional {
    SELECT source
    FROM playground_sources
    WHERE id = {id}
  }
  return switch (fetched) {
    case e as Error: responseHtml(Layout(DEFAULT_SOURCE, "", "", "db error: " + e.message, "1", "/run", pagePath))
    case row as { source: string }: runSource(row.source, runPath, pagePath)
    case none as null: responseHtml(Layout(DEFAULT_SOURCE, "", "", "snippet not found: " + id, "1", "/run", pagePath))
  }
}

function handleRunRoot(req: Request): Response {
  const source = req.form.source
  const sizeError = validateSourceSize(source)
  if (sizeError != "") {
    return responseHtml(Layout(source, "", "", sizeError, "1", "/run", "/"))
  }
  const formatted = runFormatter(source)
  const code = switch (formatted) {
    case e as Error: return responseHtml(Layout(source, "", "", "format error: " + e.message, "1", "/run", "/"))
    case formatted as string: formatted
  }
  const generated = fetch_one {
    SELECT lower(hex(randomblob(8))) AS id
  }
  const { id } = switch (generated) {
    case e as Error: return responseHtml(Layout(source, "", "", "db error: " + e.message, "1", "/run", "/"))
    case generated as { id: string }: generated
  }

  const inserted = execute {
    INSERT INTO playground_sources (id, source, updated_at)
    VALUES ({id}, {code}, datetime('now'))
  }
  return switch (inserted) {
    case e as Error: responseHtml(Layout(source, "", "", "db error: " + e.message, "1", "/run", "/"))
    case ok as undefined: responseRedirect("/" + id)
  }
}

function handleRunByID(req: Request): Response {
  const id = req.query.id
  const source = req.form.source
  if (id == "") {
    return responseHtml(Layout(source, "", "", "invalid snippet id", "1", "/run", "/"))
  }
  const pagePath = "/" + id
  const runPath = "/run/" + id

  const sizeError = validateSourceSize(source)
  if (sizeError != "") {
    return responseHtml(Layout(source, "", "", sizeError, "1", runPath, pagePath))
  }

  const formatted = runFormatter(source)
  const code = switch (formatted) {
    case e as Error: return responseHtml(Layout(source, "", "", "format error: " + e.message, "1", runPath, pagePath))
    case formatted as string: formatted
  }
    
  const updated = execute {
    INSERT OR REPLACE INTO playground_sources (id, source, updated_at)
    VALUES ({id}, {code}, datetime('now'))
  }
  return switch (updated) {
    case e as Error: responseHtml(Layout(source, "", "", "db error: " + e.message, "1", runPath, pagePath))
    case ok as undefined: responseRedirect(pagePath)
  }
}

function runSource(source: string, runPath: string, pagePath: string): Response {
  const parsed = parse(runSandbox(source))
  const raw = switch (parsed) {
    case e as Error: return responseHtml(Layout(source, "", "", "parse error: " + e.message, "1", runPath, pagePath))
    case raw as json: raw
  }

  const decoded: RunResult | Error = decode<RunResult>(raw)
  return switch (decoded) {
    case ok as RunResult: responseHtml(Layout(source, ok.stdout, ok.html, ok.error, toString(ok.exitCode), runPath, pagePath))
    case e as Error: responseHtml(Layout(source, "", "", e.message, "1", runPath, pagePath))
  }  
}

export function main(): void {
  const args = getArgs()
  const dbPath = if (args.length() > 0) {
    switch (args[0]) {
      case path as string: path
      case e as Error: "playground.sqlite3"
    }
  } else { "playground.sqlite3" }
  const opened = dbOpen(dbPath)
  if (opened as Error) {
    log("db open error: " + opened.message)
    return
  }

  const server = createServer()
  server.addRoute("get", "/", handleRoot)
  server.addRoute("post", "/run", handleRunRoot)
  server.addRoute("get", "/assets/tunascript.grammar", handleGrammar)
  server.addRoute("get", "/:id", handleSnippet)
  server.addRoute("post", "/run/:id", handleRunByID)
  const portEnv = getEnv("PORT")
  const port = if (portEnv != "") { portEnv } else { "8787" }
  log("Playground starting on http://localhost:" + port)
  server.listen(":" + port)
}
