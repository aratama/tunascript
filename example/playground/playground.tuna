import { log, to_string, fallback } from "prelude"
import { get_args, get_env } from "server"
import { parse, decode } from "json"
import { length } from "array"
import { run_sandbox, run_formatter } from "runtime"
import { create_server, add_route, listen, response_html, response_redirect, type JSX, type Request, type Response } from "http"
import { db_open } from "sqlite"
import { read_text } from "file"
import style from "./style.css"
import PLAYGROUND_EDITOR_JS from "./editor_script.js"
import TUNASCRIPT_LEZER_GRAMMAR from "./tunascript.grammar"

type RunResult = {
  stdout: string,
  html: string,
  exitCode: integer,
  error: string
}

create_table playground_sources {
  id TEXT PRIMARY KEY,
  source TEXT NOT NULL,
  updated_at TEXT NOT NULL
}

const MAX_SOURCE_SIZE_BYTES: integer = 10240
const DEFAULT_SOURCE_PATH: string = "example/playground/default_source.tuna"
const DEFAULT_SOURCE: string = read_text(DEFAULT_SOURCE_PATH).fallback("")

function layout(source: string, stdout: string, html: string, error: string, exitCode: string, run_path: string, page_path: string): JSX {
  return (
    <html>
      <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=M+PLUS+1+Code:wght@400;500;700&display=swap" />
        <title>TunaScript Playground</title>
        <style>{style}</style>
      </head>
      <body>
        <main class="layout">
          <section class="panel">
            <form method="POST" action={run_path} class="editor-form">
              <header class="bar">
                <span class="title">TunaScript Playground</span>
                <span class="actions">
                  <button class="button" type="submit">Format & Run</button>
                </span>
              </header>
              <div id="source-editor" class="editor-shell"></div>
              <textarea id="source-input" name="source" class="editor-source" spellcheck="false" wrap="off">{source}</textarea>
            </form>
          </section>
          <section class="right">
            <article class="panel">
              <header class="bar">
                <span class="title">Stdout</span>
                <span class="status">exitCode: {exitCode}</span>
              </header>
              <pre class="stdout">{stdout}</pre>
              <div class="error">{error}</div>
            </article>
            <article class="panel">
              <header class="bar">
                <span class="title">HTML Preview</span>
              </header>
              <iframe srcdoc={html} title="HTML preview"></iframe>
            </article>
          </section>
        </main>
        <script type="module">{PLAYGROUND_EDITOR_JS}</script>
      </body>
    </html>
  )
}

function validate_source_size(source: string): string {
  const checked = fetch_one {
    SELECT length(hex({source})) / 2 > {MAX_SOURCE_SIZE_BYTES} AS too_large
  }
  return switch (checked) {
    case e as error: "db error: " + e.message
    case row as { too_large: string }: if (row.too_large == "1") { "source is too large (max 10KB)" } else { "" }
  }
}

function handle_root(req: Request): Response {
  return run_source(DEFAULT_SOURCE, "/run", "/")
}

function handle_grammar(req: Request): Response {
  return response_html(TUNASCRIPT_LEZER_GRAMMAR)
}

function handle_snippet(req: Request): Response {
  const id = req.query.id
  const page_path = "/" + id
  const run_path = "/run/" + id
  if (id == "") {
    return response_html(layout(DEFAULT_SOURCE, "", "", "invalid snippet id", "1", "/run", "/"))
  }

  const fetched = fetch_optional {
    SELECT source
    FROM playground_sources
    WHERE id = {id}
  }
  return switch (fetched) {
    case e as error: response_html(layout(DEFAULT_SOURCE, "", "", "db error: " + e.message, "1", "/run", page_path))
    case row as { source: string }: run_source(row.source, run_path, page_path)
    case none as null: response_html(layout(DEFAULT_SOURCE, "", "", "snippet not found: " + id, "1", "/run", page_path))
  }
}

function handle_run_root(req: Request): Response {
  const source = req.form.source
  const size_error = validate_source_size(source)
  if (size_error != "") {
    return response_html(layout(source, "", "", size_error, "1", "/run", "/"))
  }
  const formatted = run_formatter(source)
  const code = switch (formatted) {
    case e as error: return response_html(layout(source, "", "", "format error: " + e.message, "1", "/run", "/"))
    case formatted as string: formatted
  }
  const generated = fetch_one {
    SELECT lower(hex(randomblob(8))) AS id
  }
  const { id } = switch (generated) {
    case e as error: return response_html(layout(source, "", "", "db error: " + e.message, "1", "/run", "/"))
    case generated as { id: string }: generated
  }

  const inserted = execute {
    INSERT INTO playground_sources (id, source, updated_at)
    VALUES ({id}, {code}, datetime('now'))
  }
  return switch (inserted) {
    case e as error: response_html(layout(source, "", "", "db error: " + e.message, "1", "/run", "/"))
    case ok as undefined: response_redirect("/" + id)
  }
}

function handle_run_by_id(req: Request): Response {
  const id = req.query.id
  const source = req.form.source
  if (id == "") {
    return response_html(layout(source, "", "", "invalid snippet id", "1", "/run", "/"))
  }
  const page_path = "/" + id
  const run_path = "/run/" + id

  const size_error = validate_source_size(source)
  if (size_error != "") {
    return response_html(layout(source, "", "", size_error, "1", run_path, page_path))
  }

  const formatted = run_formatter(source)
  const code = switch (formatted) {
    case e as error: return response_html(layout(source, "", "", "format error: " + e.message, "1", run_path, page_path))
    case formatted as string: formatted
  }
    
  const updated = execute {
    INSERT OR REPLACE INTO playground_sources (id, source, updated_at)
    VALUES ({id}, {code}, datetime('now'))
  }
  return switch (updated) {
    case e as error: response_html(layout(source, "", "", "db error: " + e.message, "1", run_path, page_path))
    case ok as undefined: response_redirect(page_path)
  }
}

function run_source(source: string, run_path: string, page_path: string): Response {
  const parsed = parse(run_sandbox(source))
  const raw = switch (parsed) {
    case e as error: return response_html(layout(source, "", "", "parse error: " + e.message, "1", run_path, page_path))
    case raw as json: raw
  }

  const decoded: RunResult | error = decode<RunResult>(raw)
  return switch (decoded) {
    case ok as RunResult: response_html(layout(source, ok.stdout, ok.html, ok.error, to_string(ok.exitCode), run_path, page_path))
    case e as error: response_html(layout(source, "", "", e.message, "1", run_path, page_path))
  }  
}

export function main(): void {
  const args = get_args()
  const dbPath = if (args.length() > 0) {
    switch (args[0]) {
      case path as string: path
      case e as error: "playground.sqlite3"
    }
  } else { "playground.sqlite3" }
  const opened = db_open(dbPath)
  if (opened as error) {
    log("db open error: " + opened.message)
    return
  }

  const server = create_server()
  server.add_route("get", "/", handle_root)
  server.add_route("post", "/run", handle_run_root)
  server.add_route("get", "/assets/tunascript.grammar", handle_grammar)
  server.add_route("get", "/:id", handle_snippet)
  server.add_route("post", "/run/:id", handle_run_by_id)
  const port_env = get_env("PORT")
  const port = if (port_env != "") { port_env } else { "8787" }
  log("Playground starting on http://localhost:" + port)
  server.listen(":" + port)
}
